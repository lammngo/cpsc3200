
/* Class invariants:
 * - this dataExtractor class played a role as a base/parent class and was inherited by dataHalf & dataPlus
 * - parameterized constructor takes in 1 argument
 * - each dataExtractor object encapsulated 2 integer arrays x and y that contain unique non-zero values
 * - xArray was acquired via dependancy injection so that the children classes have to perform some defined errors
 * for invalid request, thus, invalid request from users will change the state
 

 * Interface invariants:
 * - no default constructor
 * - public parameterized constructor takes in x as an integer array parameter, x is randomly generated using built-in
 * random class in the driver class. yArray will have the same size as xArray and its values are generated by
 * doubling the existing values in xArray
 * - tracking invalid state inside the parameterized constructor is provided
 * 
 * - public virtual methods:
 * + any(): return a composite array of values from xArray and yArray
 * + target(unit z): z is unit because it is a size of an array that would be returned based on the clients request.
 * this method will return an array with z number of values depends on state where all values are either odd or even
 * + sum(unit z): return a sum of z values according to state where all values are either odd or even
 *
 * - public bool IsActive(): use to check the active state of an object
 *
 * - private methods (helper functions):
 * + checkDuplicates(int[] arr): return false if an array contains duplicate values
 * 
 * - protected methods (helper function):
 * + arrayAppend(int[] arr, int val): return new array with all values copied from the old array and one new value
 * placed in the last index
 * 
 * 
 */




namespace p3;

public class dataExtractor
{
    public dataExtractor(int[] x)
    {
        if (x.Length <= 0)
        {
            isActive = false;
            inactiveCount++;
            return;
        }
        for (int i = 0; i < x.Length; i++)
        {
            xArray = arrayAppend(xArray, x[i]);
            checkDuplicates(xArray);
            yArray = arrayAppend(yArray, xArray[i] * 2);
            checkDuplicates(yArray);
        }
    }
    
    protected int[] xArray = {};
    protected int[] yArray = {};
    protected int inactiveCount, requestCount;
    protected bool isActive = true;

    
    private bool checkDuplicates(int[] arr)
    {
        for (int i = 0; i < arr.Length; i++)
        {
            for (int j = i+1; j < arr.Length; j++)
            {
                if (arr[i] == arr[j])
                {
                    isActive = false;
                    inactiveCount++;
                    return isActive;
                }
            }
        }
        return isActive; 
    }

    protected int[] arrayAppend(int[] arr, int val)
    {
        int[] newArr = new int[arr.Length+1];
        for (int i = 0; i < arr.Length; i++)
        {
            newArr[i] = arr[i];
        }
        newArr[^1] = val;
        return newArr;
    }
    
    /* Pre-conditions:
     * 1. any():
     * - Objects must be ACTIVE in order to use this method
     * - active state can be defined by having an array size bigger than 0 and an array passed in does not have any
     * duplicate values. (will illustrate this more in the implementation class)
     * 2. target(unit z):
     * - Objects must be ACTIVE in order to use this method.
     * - z must be unit, which mean it is non-zero and non-negative number because z is the size of an array that you
     * will return when you call the method
     * 3. sum(unit z):
     * - Objects must be ACTIVE in order to use this method
     * - z must be unit, which mean it is non-zero and non-negative number because z is the number of values that you
     * need to calculate for their sum
   
     * Post-conditions:
     * 1. any():
     * - return a double-sized array with composite values from both xArray and yArray because it will append the entire
     * yArray into xArray and since they have the same size (as mentioned in the interface invariants), it doubled the size
     * - requestCount will be incremented to 1 because you called the function any()
     *
     * 2. target(unit z):
     * - this method will return an array with z number of odd values if z was passed in as an odd number, or it will
     * return an array with z number of even values if z was passed in as an even number
     * - requestCount will be incremented to 1 because you called the function target(unit z)
     *
     * 3. sum(unit z):
     * - return a sum of z number of odd values if z was passed in as an odd number, or it will
     * return a sum of z number of even values if z was passed in as an even number
     * - requestCount will be incremented to 1 because you called the function sum(unit z)
     *
     * 
     */


    public virtual int[] any()
    {
        int[] arr = new int[xArray.Length*2];
        int arrIndex = 0;
        
        if (!isActive) return arr;

        for (int ele = 0; ele < xArray.Length; ele++)
        {
            arr[arrIndex++] = xArray[ele];
            arr[arrIndex++] = yArray[ele];
        }
        requestCount++;
        return arr;
    }

    public virtual int[] target(uint z)
    {
        int zCounter = 0;
        int[] arr = {};
        if (!isActive) return arr;

        foreach (var i in xArray)
        {
            if (zCounter == z) break;
            if (i % 2 == z % 2)
            {
                arr = arrayAppend(arr, i);
                zCounter++;
            }
        }
        requestCount++;
        return arr;
    }

    
    public virtual int sum(uint z)
    {
        int total = 0;

        if (!isActive) return total;

        int[] arr = target(z);
        foreach (var i in arr)
        {
            total += i;
        }
        requestCount++;
        return total;
    }
    
    public bool IsActive()
    {
        return isActive;
    }
    
    /* Implementation invariants:
     * - Implementation choices:
     * + xArray and yArray have the same size
     * + isActive, inactiveCount were used to keep track of the active state of an object, meanwhile,
     * the object is deactivated if it return false
     * + target and sum takes in z as unit because z has to be non-zero and non-negative
     * + helper functions are provided: checkDuplicates, arrayAppend
     *
     * 1. any():
     * + first created an array with a double-sized of xArray in order to store all the values from both zArray and yArray
     * + check if the objects in an array are in a valid state using isActive
     * + incremented a requestCount after finished implementing a method
     *
     * 2. target():
     * + first created a counter starts at 0 and an empty array
     * + check if the object is in invalid state
     * + if z is an odd number, append all odd number from xArray and every time you append a value into that empty
     * array, zCounter will be incremented by 1. The loop will keep appending values until the zCounter = z (that was
     * passed in)
     * + incremented a requestCount after finished implementing a method
     * 
     * 3. sum():
     * + total starts at 0
     * + target() method was reused in this function due to its similarity, total will incremented by the values that
     * was stored in a return array from the target() method
     * + incremented a requestCount after finished implementing a method
     *
     * 4. checkDuplicates():
     * + nested loop was used in order to find the duplicates
     * + it incremented the inactiveCount everytime it found a duplicate value, inactiveCount will be used to keep track
     * of the object state in dataHalf
     *
     * 5. arrayAppend():
     * + newArr with a size bigger than 1 comparing to the array that was passed in because it copied everything from
     * the old array over and placed any new value in the last index
     *
     */
}
